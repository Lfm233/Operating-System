代码调试过程中遇到过的错误
一、虚拟存储模块出现的问题
一、共同出现的问题
在实现多个页面置换算法时，您遇到了一些共同的问题，这些问题主要源自于 数据结构的管理和初始化。具体包括：

共享数据结构导致算法间干扰：
问题：所有算法（FIFO、LRU、LFU）共享同一个 frames 向量。当一个算法修改了 frames 的内容，其他算法在运行时会受到影响，导致输出结果不正确。
原因：在同一个 VirtualMemory 实例中连续调用不同的页面置换算法，而不对共享的数据结构进行适当的重置或隔离。
改进方式：
重置 frames 向量：在每个算法运行之前，调用 resetFrames() 方法将 frames 向量重置为初始状态（如全部设为 -1 表示空帧）。
使用独立的实例：在调试或测试模式中，为每个算法创建独立的 VirtualMemory 实例，确保它们拥有各自独立的 frames 向量，不会相互干扰。
二、各个算法出现的问题及改进方式
1. FIFO（先进先出）算法
遇到的问题
输出表格头与数据不一致：在某些情况下，输出的帧状态与预期不符，可能是由于 frames 向量未被正确重置，导致之前算法的结果影响当前算法。
原因分析
共享 frames 向量：当多个算法连续运行时，FIFO 算法的帧状态影响了后续算法的初始状态。
改进方式
重置 frames 向量：在 FIFO 算法运行前，调用 resetFrames() 方法，确保 frames 向量处于初始状态。
独立实例运行：在调试模式中，为 FIFO 算法创建独立的 VirtualMemory 实例。
2. LRU（最近最少使用）算法
遇到的问题
输出结果错误：尤其是在第四次页面置换之后，帧状态显示不正确，例如所有帧显示相同的页面，无法反映正确的最近使用情况。
原因分析
共享 frames 向量：
frames 向量在不同算法间共享，FIFO 算法运行后修改了 frames，导致 LRU 算法基于错误的初始状态运行。
不正确的页面使用跟踪：
未能准确记录和更新页面的使用顺序，导致替换时选择错误的页面。
改进方式
重置 frames 向量：
在 LRU 算法运行前，调用 resetFrames() 方法，将 frames 向量重置为初始状态。
准确跟踪页面使用顺序：
使用适当的数据结构（如 std::list）来记录页面的使用顺序，确保在页面命中时能够正确更新使用顺序。
独立实例运行：
在调试模式中，为 LRU 算法创建独立的 VirtualMemory 实例，避免与其他算法的数据干扰。
最终解决方案
通过重置 frames 向量和使用正确的页面使用跟踪机制，确保 LRU 算法能够准确反映最近的页面使用情况，正确执行页面替换。
3. LFU（最不经常使用）算法
遇到的问题
输出结果在第四次置换后不正确：帧状态未能正确反映最不经常使用的页面被替换，导致替换逻辑出错。
原因分析
不一致的数据结构使用：
使用了 memory 向量来跟踪当前加载的页面，而未统一使用 frames 向量，导致数据不一致。
不完善的置换逻辑：
在多个页面具有相同最低访问频率时，未能正确选择最早加载的页面进行替换。
共享 frames 向量：
同样，frames 向量在不同算法间共享，影响了 LFU 算法的初始状态。
改进方式
统一使用 frames 向量：
移除独立的 memory 向量，统一使用 frames 向量来跟踪当前加载的页面，确保数据结构的一致性。
重置 frames 向量：
在 LFU 算法运行前，调用 resetFrames() 方法，将 frames 向量重置为初始状态。
准确记录页面频率和加载时间：
使用 frequency_map 记录每个页面的访问频率。
使用 load_time_map 记录每个页面被加载到帧中的时间，以便在频率相同的情况下选择最早加载的页面进行替换。
优化置换逻辑：
在需要置换时，首先找到访问频率最低的页面。
如果有多个页面具有相同的最低频率，选择最早加载的页面进行替换，确保符合 LFU 的行为。
最终解决方案
通过统一使用 frames 向量，准确记录页面访问频率和加载时间，并优化置换逻辑，确保 LFU 算法能够正确地识别和替换最不经常使用的页面。

二、文件管理出现的问题
sstf和scan算法都出现初始磁头位置没有正确初始化，打印函数没有正确保持初始磁头位置。    int previous_position = this->current_position; // 保持初始磁头位置

三、进程管理模块的问题
时间片轮转调度中当一个进程的运行时间大于时间片的时间，原本该进程需要被暂停放到队尾，但是原先代码会继续执行，不会暂停和放到队尾。

代码整合过程中的问题
整合困难，因为写的函数多，所以逻辑比较杂，而且代码量也比单个调试要大得多。